<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>UART and printf — GPIO Pin Configuration</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

</head>
<body class="bg-light text-dark">
  <div class="container py-5">

    <div class="alert alert-info">
      Reference: <a href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" target="_blank">
        Broadcom BCM2835 ARM Peripherals Manual (PDF)
      </a>
    </div>

    <a href="index.html" class="btn btn-outline-secondary mb-4">⭠ Back to Home</a>
    <h1>UART and printf</h1>
    <p class="lead">
      In this section, we will focus on configuring the GPIO pins to enable UART0 output on the Raspberry Pi 3B.
    </p>
    <hr>

    <h2>Setting GPIO14 and GPIO15 to ALT0 for UART0</h2>
    <pre><code>selector = get32(GPFSEL1);
selector &= ~(7 << 12);                   // Clear bits 14:12 for GPIO14
selector |=  (4 << 12);                   // Set bits 14:12 to ALT0
selector &= ~(7 << 15);                   // Clear bits 17:15 for GPIO15
selector |=  (4 << 15);                   // Set bits 17:15 to ALT0
put32(GPFSEL1, selector);</code></pre>

    <h3>What is ALT0?</h3>
    <p>
      On the Raspberry Pi, most GPIO pins are multiplexed, which means each pin can perform multiple functions depending on how you configure it. In our case, we will be configuring it for UART.
    <p>
      Each GPIO pin supports several alternate functions named <code>ALT0</code>, <code>ALT1</code>, <code>ALT2</code>, and so on. These correspond to different internal hardware blocks. For example:
    </p>
    <ul>
      <li><code>ALT0</code> for GPIO14 = UART0 transmit (TXD0)</li>
      <li><code>ALT0</code> for GPIO15 = UART0 receive (RXD0)</li>
    </ul>

    <h3>What is GPFSEL1?</h3>
    <p>
       GPFSEL stands for GPIO Function Select which are registers that determine what function each GPIO pin performs. There are six of these registers: <code>GPFSEL0</code> through <code>GPFSEL5</code>. Each register controls 10 GPIO pins and each pin requires 3 bits to set its function.
    </p>
    <p>
      <code>GPFSEL1</code> covers GPIO pins 10 through 19. We care about:
    </p>
    <ul>
      <li><strong>GPIO14</strong>, which maps to bits <code>14:12</code> of <code>GPFSEL1</code></li>
      <li><strong>GPIO15</strong>, which maps to bits <code>17:15</code> of <code>GPFSEL1</code></li>
    </ul>
    <p>
      The function values are as follows:
    </p>
    <ul>
      <li><code>000</code> = Input</li>
      <li><code>001</code> = Output</li>
      <li><code>100</code> = ALT0 (which is UART0 for these pins)</li>
    </ul>

    <h3>Explanation of the Code</h3>
    <ul>
      <li>
        <code>get32(GPFSEL1)</code> reads the current value of the GPIO Function Select register for GPIOs 10–19. 
        Since GPIO14 and GPIO15 fall into this range, we start by fetching the current state so we can modify only the bits we care about without affecting other pins.
      </li>
      <li>
        <code>&amp;= ~(7 &lt;&lt; 12)</code> clears bits 14–12, which correspond to the function select field for GPIO14. 
        We must clear them first because we’re about to change this pin’s function, and we want to avoid leaving leftover bits that might point to a different mode.
      </li>
      <li>
        <code>|= 4 &lt;&lt; 12</code> sets bits 14–12 to <code>100</code>, which configures GPIO14 to use <code>ALT0</code>. 
        On the Pi 3B, this routes the pin to UART0’s TX (transmit) function.
      </li>
      <li>
        <code>&amp;= ~(7 &lt;&lt; 15)</code> and <code>|= 4 &lt;&lt; 15</code> perform the exact same logic for GPIO15, clearing its function bits and setting them to ALT0 mode. 
        This enables the UART0 RX (receive) line on that pin.
      </li>
      <li>
        <code>put32(GPFSEL1, selector)</code> writes the modified configuration back into the <code>GPFSEL1</code> register. 
        Only now do we commit the changes to the hardware, ensuring both pins are connected to the UART0 peripheral.
      </li>
    </ul>
    

    <p>
      After this configuration, GPIO14 and GPIO15 are connected to the UART0 hardware block inside the SoC. This allows us to send and receive serial data using the UART0 peripheral.
    </p>

    <h2>Disabling Pull-Up/Down Resistors</h2>
<pre><code>// Disable pull-up/down for all GPIO pins & delay for changes to take effect
put32(GPPUD, 0);
delay(150);
put32(GPPUDCLK0, (1 << 14) | (1 << 15));
delay(150);
put32(GPPUDCLK0, 0);</code></pre>

<p>
  GPIO pins on the Raspberry Pi have configurable internal pull-up and pull-down resistors. These resistors help stabilize the voltage level of a pin when it is not actively driven. Without them, a floating input pin could pick up random noise and behave unpredictably.
</p>

<p>
  When we use pins for UART (GPIO14 and GPIO15), we do not want any internal pull resistors affecting the voltage levels. UART lines are actively driven by both the Pi and the device it communicates with, so internal resistors would interfere with signal clarity.
</p>

<h3>Explanation of the Code</h3>
<ul>
  <li>
    <code>put32(GPPUD, 0)</code> writes <code>0</code> to the GPIO Pull-Up/Down (PUD) register, which disables any internal pull-up or pull-down resistors for all GPIO pins. 
    This is important because UART lines (TX and RX) are actively driven and shouldn’t be influenced by internal bias resistors.
  </li>
  <li>
    <code>delay(150)</code> introduces a short delay to give the new setting time to propagate internally before applying it to specific pins. 
    According to the Broadcom documentation (page 101), this delay is required to ensure the next step functions correctly.
  </li>
  <li>
    <code>put32(GPPUDCLK0, (1 &lt;&lt; 14) | (1 &lt;&lt; 15))</code> writes to the Pull-Up/Down Clock register. 
    This doesn't set a clock, it’s a mechanism that tells the hardware, “apply the pull setting we just configured (from <code>GPPUD</code>) to GPIO14 and GPIO15.” 
    Setting bits 14 and 15 targets those specific pins.
  </li>
  <li>
    <code>delay(150)</code> ensures the pull-up/down setting has enough time to latch into the target pins before we remove the clock signal.
  </li>
  <li>
    <code>put32(GPPUDCLK0, 0)</code> clears the clock bits, which finalizes the configuration. 
    Without this final step, the change may not reliably take effect, especially on real hardware.
  </li>
</ul>


<p>
  This is how the Raspberry Pi’s hardware expects pull-up/down settings to be configured. If you skip it or apply it incorrectly, there is a chance UART output will be unstable.
</p>

<h2>Setting the Baud Rate</h2>
<pre><code>put32(UART0_IBRD, 26);  // Integer part of baud rate divisor
put32(UART0_FBRD, 3);   // Fractional part of baud rate divisor</code></pre>

<p>
  These two lines configure the baud rate for UART0, which determines how fast data is sent and received over the serial line. 
  The UART clock on the Raspberry Pi 3B is typically set to 48 MHz, and we want a standard baud rate of <code>115200</code> bits per second for serial communication.
</p>

<h3>Baud Rate Divisor Formula</h3>
<p>
  The UART uses a clock divider to compute the baud rate from the source clock. The equation is:
</p>

<p style="font-size: 1.2em;">
  $$ \textbf{BaudDiv} = \frac{\text{UART_CLK}}{16 \times \text{BaudRate}} $$
</p>


<p>
  For a 48 MHz UART clock and a target baud rate of 115200:
</p>

<p style="font-size: 1.2em;">
  $$ \text{BaudDiv} = \frac{48{,}000{,}000}{16 \times 115200} \approx 26.041666\ldots $$
</p>

<h3>Breaking That Into Registers</h3>
<ul>
  <li>
    <code>UART0_IBRD</code> gets the integer part of the divisor. In this case:
    $$ \text{Integer} = 26 $$
  </li>
  <li>
    <code>UART0_FBRD</code> gets the fractional part, which is calculated with:
    $$ \text{Fractional} = \text{round}\left((\text{BaudDiv} - \text{Integer}) \times 64\right) $$
    $$ \text{Fractional} = \text{round}(0.041666 \times 64) \approx 3 $$
  </li>
</ul>
<p>
  These two values together configure UART0 to produce a baud rate close to 115200. If the values are off, the receiving end may misinterpret the signal which would result in a lot of garbled text.
</p>

<h3>UART0_LCRH – Line Control Register</h3>
<p>
  This register sets the format of the data being transmitted and received over UART.
</p>

<ul>
  <li><code>(1 &lt;&lt; 4)</code> sets the <strong>FEN</strong> bit (FIFO Enable). This enables both the transmit and receive <strong>FIFO (First In, First Out)</strong> buffers inside the UART hardware.</li>
</ul>

<p>
  Each FIFO is a 16-byte queue that temporarily holds data as it's sent or received. Without FIFO enabled, the UART can only hold a single byte at a time in each direction, meaning the CPU must read or write each character exactly when it arrives or is ready to send—any delay might cause data loss or missed bytes.
</p>

<p>
  With FIFOs enabled, the CPU doesn’t have to respond immediately to every character. The transmit FIFO can queue up to 16 bytes to be sent, and the receive FIFO can store up to 16 bytes that were received while the CPU was busy. This improves reliability and reduces how often the CPU must service the UART.
</p>

<p>
  If you want to visually see this, there is this really cool interactive tool 
  from Dr. Valvano from the ECE majors:
  <a href="https://users.ece.utexas.edu/~valvano/Volume1/IntroToEmbSys/Ch9_SerialCommunication.htm#9_4" target="_blank">
    UART FIFO Demo  – Dr. Valvano's Embedded Systems (scroll to Interactive Tool 9.4)
  </a>.
</p>


<ul>
  <li><code>(1 &lt;&lt; 5) | (1 &lt;&lt; 6)</code> sets the word length to <strong>8 bits</strong>. The combination <code>WLEN[1:0] = 0b11</code> tells the UART to send and receive data as 8-bit values, which is standard for most text-based communication.</li>
</ul>

<p>
  These bits are the final step in the UART bring-up process. Without them, nothing would flow in or out of the UART hardware—even if everything else was configured correctly.
</p>



  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
