<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Booting on Real Hardware | Diego's Bare-Metal Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body class="bg-light text-dark">
  <div class="container py-5">
    <a href="index.html" class="btn btn-outline-secondary mb-4">‚Üê Back to Home</a>
    <h1>Booting on Real Raspberry Pi 3B Hardware</h1>
    <p class="lead">
      From power-on ROM to your first C function‚Äîlet‚Äôs see how the Pi 3B GPU firmware loads your kernel, and then exactly what each assembly instruction does to get you into EL1.
    </p>
    <hr>

    <h2>Power-On to <code>kernel8.img</code></h2>
    <p>
      On reset, the Broadcom SoC‚Äôs on-chip ROM (running on the GPU) reads the SD card‚Äôs FAT32 boot partition. It first loads:
    </p>
    <ul>
      <li><code>bootcode.bin</code> ‚Üí initializes SDRAM</li>
      <li><code>start.elf</code> ‚Üí the closed-source GPU firmware</li>
    </ul>
    <p>
      Finally, <code>start.elf</code> reads and copies your <code>kernel8.img</code> into RAM and jumps to its entry point‚Äîyour `_start` label‚Äîrunning initially in EL2 on core 0.
    </p>

    <h2>Core ID Check & Secondary Parking</h2>
    <pre><code>_start:
    mrs   x0, mpidr_el1
    and   x0, x0, #0xFF        // core ID = bits[7:0]
    cbz   x0, master           // if core 0 ‚Üí master
    b     proc_hang            // else park</code></pre>
    <p>
      - <code>mpidr_el1</code> tells us which CPU we‚Äôre on.<br>
      - Non-zero cores go to <code>proc_hang</code>:
    </p>
    <pre><code>proc_hang:
    wfe                         // wait for event (low-power spin)
    b proc_hang</code></pre>
    <p>
      They‚Äôll remain here until we later issue a `sev` to wake them.
    </p>

    <h2>üîß 3. Master Core EL2 Setup</h2>
    <pre><code>master:
    // Prevent FP/SIMD and sysreg traps
    mov   x0, #0x33FF
    msr   cptr_el2, x0         // CPTR_EL2: no trap to EL2
    msr   hstr_el2, xzr        // HSTR_EL2: no sysreg traps

    // Enable full FP/SIMD in EL1
    mrs   x0, CPACR_EL1
    orr   x0, x0, #(0b01<<20) | (0b01<<21)
    msr   CPACR_EL1, x0</code></pre>
    <ul>
      <li><strong>CPTR_EL2</strong>: stops FP/SIMD ops from trapping back to EL2.</li>
      <li><strong>HSTR_EL2</strong>: stops system-register traps.</li>
      <li><strong>CPACR_EL1[21:20]=11</strong>: allows EL1 full FP/SIMD access.</li>
    </ul>

    <h2>‚öôÔ∏è 4. Hypervisor Configuration & Vector Base</h2>
    <pre><code>    // Switch EL1 to AArch64
    ldr   x0, =HCR_VALUE
    msr   hcr_el2, x0

    // Point EL1 exceptions to our table
    ldr   x0, =_vectors
    msr   vbar_el1, x0</code></pre>
    <p>
      - <code>HCR_EL2.RW=1</code> ‚Üí EL1 runs 64-bit.<br>
      - <code>VBAR_EL1</code> ‚Üí where EL1 exception handlers live.
    </p>

    <h2>Prepare & Perform EL2‚ÜíEL1 Transition</h2>
    <pre><code>    // Prepare return to EL1h (mask interrupts)
    mov   x0, #0x3C4
    msr   spsr_el2, x0

    // Set EL1 PC to el1_entry
    adr   x0, el1_entry
    msr   elr_el2, x0

    eret                         // drop to EL1h</code></pre>
    <p>
      - <strong>SPSR_EL2</strong>: sets PSTATE for EL1h, IRQ/FIQ/SError masked.<br>
      - <strong>ELR_EL2</strong>: return address = <code>el1_entry</code>.<br>
      - <code>eret</code>: performs the switch into EL1.
    </p>

    <h2>EL1 Entry, BSS Clear & Stack Setup</h2>
    <pre><code>el1_entry:
    // Zero .bss
    adr   x0, __bss_start
    adr   x1, __bss_end
    sub   x1, x1, x0
    bl    memzero

    // Build safe C stack directly in EL1
    mov   sp, #LOW_MEMORY
    bl    pickKernelStack     // returns final SP in x0
    mov   sp, x0

    bl    primary_kernel_init
    b     proc_hang</code></pre>
    <ul>
      <li><code>memzero</code>: wipes uninitialized data.</li>
      <li>We explicitly set <code>sp</code> in EL1 (not via <code>sp_el1</code>), then call C.</li>
    </ul>

    <h2>Waking Secondary Cores</h2>
    <pre><code>wake_up_cores:
    adr   x0, secondary
    str   x0, [0xE0]           // entry for core 1
    str   x0, [0xE8]           // core 2
    str   x0, [0xF0]           // core 3
    sev                         // send-event wakes them</code></pre>

    <h2>Secondary Core Startup in EL1</h2>
    <pre><code>secondary_kernel_main:
    // compute per-core stack
    mrs   x0, mpidr_el1
    and   x0, x0, #0xFF
    mov   x1, #SECTION_SIZE
    mul   x1, x1, x0
    add   x1, x1, #LOW_MEMORY
    mov   sp, x1
    bl    pickKernelStack
    mov   sp, x0

    bl secondary_kernel_init
    b  proc_hang</code></pre>
    <p>
      Secondary cores skip the EL2 setup (it was done once globally) and simply set up their own C stack in EL1 before calling C.
    </p>

    <h2>Exception Vector Table</h2>
    <pre><code>.align 11
_vectors:
  // sync
  .align 7
  mov x0,#0; mrs x1,esr_el1; mrs x2,elr_el1; mrs x3,spsr_el1; mrs x4,far_el1
  b exc_handler

  // IRQ
  .align 7
  mov x0,#1; mrs x1,esr_el1; mrs x2,elr_el1; mrs x3,spsr_el1; mrs x4,far_el1
  b exc_handler

  // FIQ & SError similarly‚Ä¶</code></pre>

    <hr>
    <p><em>
      By explicitly setting up your stack in EL1 and handling all traps and vector bases in EL2, this sequence takes you reliably from raw hardware into a fully-running C kernel on core 0‚Äîand then wakes up the other cores to do the same.
    </em></p>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
