<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Booting on Real Hardware | Diego's Bare-Metal Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body class="bg-light text-dark">
  <div class="container py-5">
    <a href="index.html" class="btn btn-outline-secondary mb-4">← Back to Home</a>
    <h1>Booting on Real Raspberry Pi 3B Hardware</h1>
    <p class="lead">
      In this lecture, we’ll dissect every step of the Pi’s primary core initialization—starting from GPU firmware handoff, through EL2 setup, and ending with your first C function call in EL1.
    </p>
    <hr>

    <h2>1. From Power-On ROM to <code>kernel8.img</code></h2>
    <p>
      At reset, the Pi’s GPU ROM loads <code>bootcode.bin</code> (which brings up SDRAM) followed by <code>start.elf</code>. Those two binaries configure clocks, power domains, and peripherals, then load your <code>kernel8.img</code> into RAM. Once that’s complete, execution jumps to your <code>_start</code> label in EL2 on core 0.
    </p>

    <h2>2. Identifying the Active Core</h2>
    <pre><code>_start:
    mrs   x0, mpidr_el1
    and   x0, x0, #0xFF        // extract core index (0–3)
    cbz   x0, master           // if zero, proceed
    b     proc_hang            // otherwise park</code></pre>
    <p>
      We read <code>MPIDR_EL1</code> to learn our core ID. Core 0 continues; cores 1–3 enter a low-power loop.
    </p>

    <h2>3. Parking Secondary Cores</h2>
    <pre><code>proc_hang:
    wfe                        // wait for event
    b     proc_hang            // loop indefinitely</code></pre>
    <p>
      Secondary cores will remain here until we later issue a <code>sev</code>.
    </p>

    <h2>4. Disabling Traps in EL2</h2>
    <pre><code>master:
    // disable FP/SIMD traps to EL2
    mov   x0, #0x33FF
    msr   cptr_el2, x0
    msr   hstr_el2, xzr

    // enable full FP/SIMD at EL1
    mrs   x0, CPACR_EL1
    orr   x0, x0, #(0b01<<20)|(0b01<<21)
    msr   CPACR_EL1, x0</code></pre>
    <p>
      We prevent any floating-point or system-register access in EL1 from trapping back to EL2, and explicitly grant EL1 full SIMD/FPU privileges.
    </p>

    <h2>5. Configuring the Hypervisor Register and VBAR</h2>
    <pre><code>    // switch EL1 to AArch64
    ldr   x0, =HCR_VALUE
    msr   hcr_el2, x0

    // point EL1 exceptions to our vector table
    ldr   x0, =_vectors
    msr   vbar_el1, x0</code></pre>
    <p>
      Setting <code>HCR_EL2.RW=1</code> ensures EL1 runs in 64-bit mode. We also install our exception handlers now.
    </p>

    <h2>6. Preparing the EL2→EL1 Transition</h2>
    <pre><code>    // set up SPSR_EL2: return to EL1h, interrupts masked
    mov   x0, #0x3C4
    msr   spsr_el2, x0

    // set exit address for EL1
    adr   x0, el1_entry
    msr   elr_el2, x0

    eret                        // drop to EL1h</code></pre>
    <p>
      Here we configure the processor state for EL1h (using its own stack pointer, with IRQ/FIQ/SError masked) and then execute <code>eret</code> to enter EL1.
    </p>

    <h2>7. Entry into EL1: BSS Clearing and Stack Setup</h2>
    <pre><code>el1_entry:
    // zero .bss
    adr   x0, __bss_start
    adr   x1, __bss_end
    sub   x1, x1, x0
    bl    memzero

    // explicit stack setup in EL1
    mov   sp, #LOW_MEMORY
    bl    pickKernelStack   // returns final SP in x0
    mov   sp, x0

    bl    primary_kernel_init
    b     proc_hang</code></pre>
    <p>
      We clear uninitialized data, then build a safe stack for C by first assigning a known base (<code>LOW_MEMORY</code>), calling <code>pickKernelStack</code>, and finally setting <code>sp</code> to the returned value. This guarantees that our first C calls run on a valid stack.
    </p>

    <h2>8. Waking the Remaining Cores</h2>
    <pre><code>wake_up_cores:
    adr   x0, secondary
    str   x0, [0xE0]         // core 1 entry
    str   x0, [0xE8]         // core 2
    str   x0, [0xF0]         // core 3
    sev                       // wake them from wfe</code></pre>
    <p>
      We write the EL1 entry address into each core’s mailbox and then signal them with <code>sev</code>.
    </p>

    <h2>9. Secondary Core Startup in EL1</h2>
    <pre><code>secondary_kernel_main:
    mrs   x0, mpidr_el1
    and   x0, x0, #0xFF
    mov   x1, #SECTION_SIZE
    mul   x1, x1, x0
    add   x1, x1, #LOW_MEMORY
    mov   sp, x1

    bl    pickKernelStack
    mov   sp, x0

    bl    secondary_kernel_init
    b     proc_hang</code></pre>
    <p>
      Each secondary core, now in EL1, computes its own stack base and repeats the same explicit stack setup before jumping into its C initialization.
    </p>

    <h2>10. The Exception Vector Table</h2>
    <pre><code>.align 11
_vectors:
  // synchronous
  .align 7
  mov x0,#0; mrs x1,esr_el1; mrs x2,elr_el1; mrs x3,spsr_el1; mrs x4,far_el1
  b exc_handler

  // IRQ
  .align 7
  mov x0,#1; mrs x1,esr_el1; mrs x2,elr_el1; mrs x3,spsr_el1; mrs x4,far_el1
  b exc_handler

  // FIQ and SError follow similarly…</code></pre>
    <p>
      This table defines handlers for synchronous exceptions, IRQ, FIQ, and SError. Each entry captures key registers and branches to a common <code>exc_handler</code>.
    </p>

    <hr>
    <p>
      With these steps, we have built a reliable, explicit path from the GPU firmware’s handoff all the way into C on core 0, and then brought every other core along the same path. This pattern—clear trap disabling, explicit stack setup, and precise EL2→EL1 transition—forms a robust foundation for your bare-metal kernel.
    </p>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
