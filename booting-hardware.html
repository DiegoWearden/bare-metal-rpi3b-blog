<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Booting on Raspberry Pi 3B Hardware</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body class="bg-light text-dark">
  <div class="container py-5">
    <a href="index.html" class="btn btn-outline-secondary mb-4">← Back to Home</a>
    <h1>Early Hardware Initialization</h1>
    <p class="lead">
      Here’s how the Pi goes from power-on ROM to running your first C function in EL1. We’ll walk through each assembly step on the primary core, then show how the other cores join in.
    </p>
    <hr>

    <h2>1. GPU Firmware to Kernel Handoff</h2>
    <p>
      When the Raspberry Pi 3B powers on, the CPU doesn't start running right away. Instead, the GPU is the first to wake up. It runs a small bit of code from on-chip ROM that loads <code>bootcode.bin</code> from the SD card, which sets up the SDRAM so the system has usable memory. Then it loads <code>start.elf</code>, which configures things like the system clock and power management. Once everything is set up, the GPU loads your <code>kernel8.img</code> into memory and jumps to the <code>_start</code> label. At this point, core 0 begins executing your code in EL2.
    </p>    
    

    <h2>2. “Who Am I?”: Core ID Check</h2>
    <pre><code>_start:
        mrs   x0, mpidr_el1          // Read the Multiprocessor Affinity Register
        and   x0, x0, #0xFF          // Keep only the lowest 8 bits (core number)
        cbz   x0, master             // If that number is zero, we’re on core 0
        b     proc_hang              // Otherwise, park this core</code></pre>
    <p>
      When the CPU resets, every core has the same code in memory, but only one of them (core 0) actually needs to run the initialization sequence right away. We read <code>MPIDR_EL1</code>, which among other things tells us “I’m core 0,” “I’m core 1,” up to “I’m core 3.” The lowest eight bits of that register (called “Affinity Level 0”) hold exactly that piece of information. By masking with <code>0xFF</code>, we strip away everything else and end up with a number from 0 to 3. If it’s zero, this is the primary core and we jump into the <code>primary</code> setup. If it’s non-zero, we branch to <code>proc_hang</code> and wait quietly until the primary core wakes us later on.
    </p>
    
    

    <h2>3. Parking Secondary Cores</h2>
    <pre><code>proc_hang:
        wfe                     // Wait For Event: core goes into a low-power sleep
        b     proc_hang         // loop back and sleep again</code></pre>
    <p>
      Although on the real Pi 3B only core 0 ever enters our <code>_start</code> sequence at reset, we include this “parking” loop for cores 1–3 in case they do reach our code (for example in simulators or future platforms). Any core that branches here will sleep in place:  
      1. <code>wfe</code> halts the core until an event (a <code>sev</code>) arrives.  
      2. The branch back to <code>proc_hang</code> ensures it goes right back to sleep if no new work is ready.  
    
      In actual hardware, cores 1–3 start stalled inside the GPU’s ROM spin-loop and only get released when the primary core writes their start address into the mailboxes and issues <code>sev</code>. Once they land in our <code>secondary_kernel_main</code> code, this same parking loop is never used—instead, they follow the “wakeup” path we explicitly drive.  
    </p>
    

    <h2>4. Disabling Traps in EL2</h2>
    <pre><code>master:
        mov   x0, #0x33FF
        msr   cptr_el2, x0         // stop FP/SIMD faults to EL2
        msr   hstr_el2, xzr        // stop system-register traps
    
        mrs   x0, CPACR_EL1
        orr   x0, x0, #(1<<20)|(1<<21)
        msr   CPACR_EL1, x0        // allow FP/SIMD in EL1</code></pre>
    <p>
      These instructions disable traps that would otherwise occur when EL1 code tries to access floating-point or SIMD instructions. I'm still not completely sure why this setup is needed just to drop from EL2 to EL1, since no floating-point code runs at that point. However, I do know that if this part is left out, later code that uses floating-point instructions (either directly or through compiled C functions) will crash. So even if the immediate effect isn't obvious, it's important to have this in place early.
    </p>
    

    <h2>5. Setting Up the Hypervisor Register and VBAR</h2>
    <pre><code>
        ldr   x0, =HCR_VALUE
        msr   hcr_el2, x0          // Set EL1 to use AArch64 execution state
    
        ldr   x0, =_vectors
        msr   vbar_el1, x0         // Set the exception vector base address for EL1</code></pre>
    <p>
      The <code>HCR_EL2</code> register controls how EL1 behaves when we return to it from EL2. Specifically, setting the <code>RW</code> bit (bit 31) to 1 tells the CPU that EL1 should run in AArch64 mode rather than AArch32. If this isn’t set, your code might end up running in the wrong execution state and behave unpredictably (or not at all).
    
      After that, we configure <code>VBAR_EL1</code>, which is the vector base address register for EL1. This tells the processor where to jump when an exception occurs (like an interrupt, system call, or fault) while running in EL1. By pointing it to our own <code>_vectors</code> table, we make sure any exceptions in our kernel get handled by our own code, not some undefined location.
    </p>
    

    <h2>6. Preparing to Return to EL1</h2>
    <pre><code>
        mov   x0, #0x3C4
        msr   spsr_el2, x0         // Set up the saved program status for EL1
    
        adr   x0, el1_entry
        msr   elr_el2, x0          // Set the return address for when we drop to EL1
    
        eret                       // Exception return: jump to EL1</code></pre>
    <p>
      Before we can drop from EL2 to EL1, we need to tell the processor what kind of state EL1 should start in. <code>SPSR_EL2</code> controls that. The value <code>0x3C4</code> tells the CPU to enter EL1 in handler mode, which means it will use <code>sp_el1</code> as the active stack pointer. It also masks interrupts so they do not interfere with our setup.
    
      Next, we set <code>ELR_EL2</code>, which is the return address for when the CPU exits the current exception level. This is where the processor will jump once we execute <code>eret</code>. We point it to <code>el1_entry</code>, which is where our EL1 code begins.
    
      Finally, <code>eret</code> performs the transition. The CPU exits EL2 and starts executing at the address in <code>ELR_EL2</code> using the settings we placed in <code>SPSR_EL2</code>.
    </p>
    

    <h2>7. EL1 Entry: BSS Clear and Stack Setup</h2>
    <pre><code>el1_entry:
        adr   x0, __bss_start
        adr   x1, __bss_end
        sub   x1, x1, x0
        bl    memzero              // clear .bss
    
        mov   sp, #LOW_MEMORY      // temporary stack
        bl    pickKernelStack      // returns final SP in x0
        mov   sp, x0               // use it now
    
        bl    primary_kernel_init
        b     proc_hang</code></pre>
    <p>
      When we enter EL1, the first thing we do is clear the <code>.bss</code> section. This section contains all global and static variables that are uninitialized or implicitly initialized to zero. The C runtime expects these to be zeroed out before execution begins. We calculate the size of the section and call <code>memzero</code> to clear it.
    
      This includes things like the <code>stacks</code> object, which is a global variable with no explicit initializer. Even though it reserves a large amount of memory, it goes into the <code>.bss</code> section and is not stored in the binary itself. The bootloader (or in our case, this code) ensures that it starts out filled with zeros.
    
      After that, we need a working stack. We first set <code>sp</code> to a known safe memory location to avoid crashing during early setup. Then we call <code>pickKernelStack</code>, which returns a stack pointer based on the core ID. Once we have the correct address, we switch <code>sp</code> over to it and continue.
    
      With memory cleared and a proper stack in place, we can safely enter C by calling <code>primary_kernel_init</code>.
    </p>
    
    

    <h2>8. Waking Up Secondary Cores</h2>
    <pre><code>wake_up_cores:
        adr   x0, setup_el1_for_secondary
        str   x0, [0xE0]           // entry for core 1
        str   x0, [0xE8]           // core 2
        str   x0, [0xF0]           // core 3
        sev                        // send event</code></pre>
    <p>
      When the Raspberry Pi powers on, only core 0 begins execution. The other cores are held in a low-power state using the <code>wfe</code> instruction. To bring them online, we write the address of our secondary core entry point into fixed memory locations that act as mailboxes for each core: 0xE0 for core 1, 0xE8 for core 2, and 0xF0 for core 3. These are monitored by the firmware. After writing the addresses, the <code>sev</code> instruction is used to broadcast a signal that wakes all sleeping cores.
    
      This function is typically called after core 0 has completed its early initialization tasks. That includes setting up the UART, enabling <code>printf</code>, configuring the heap, and bringing up any necessary drivers or subsystems. By the time the secondary cores start running, the system is already in a usable state. This avoids repeating expensive initialization steps on every core and lets the secondaries immediately start using the infrastructure set up by core 0.
    </p>

    <h2>9. EL2-to-EL1 Transition for Secondary Cores</h2>
    <pre><code>
    setup_el1_for_secondary:
    mov   x0, #0x33FF
    msr   cptr_el2, x0         // disable coprocessor traps
    msr   hstr_el2, xzr        // disable sysreg traps
    mov   x0, #(3 << 20)
    msr   cpacr_el1, x0        // enable FP/SIMD in EL1

    ldr   x0, =HCR_VALUE
    msr   hcr_el2, x0          // set EL1 to run in AArch64

    ldr   x0, =SPSR_VALUE
    msr   spsr_el2, x0         // saved program status for EL1

    adr   x0, secondary_kernel_main
    msr   elr_el2, x0          // where execution resumes in EL1

    eret                        // drop to EL1</code></pre>
    <p>
  After each secondary core is woken up, it begins in EL2. Just like with core 0, we need to prepare for the switch into EL1. This involves disabling traps that would otherwise cause EL1 to fault if it accessed FP/SIMD or system registers. We then set <code>HCR_EL2</code> so that EL1 runs in 64-bit mode.

  Next, we set <code>SPSR_EL2</code> to configure how the processor will behave when entering EL1. We set <code>ELR_EL2</code> to the address of <code>secondary_kernel_main</code>, which is where the core will jump once it exits EL2.

  Finally, we call <code>eret</code>, which exits the current exception level and transfers control to EL1. From this point on, the core is running in the same environment as core 0.
    </p>

    
    
    

    <h2>10. Secondary Core Initialization</h2>
    <pre><code>secondary_kernel_main:
        mrs   x0, mpidr_el1
        and   x0, x0, #0xFF
        mov   x1, #SECTION_SIZE
        mul   x1, x1, x0
        add   x1, x1, #LOW_MEMORY
        mov   sp, x1               // temporary stack
    
        bl    pickKernelStack
        mov   sp, x0               // final stack
    
        bl    secondary_kernel_init
        b     proc_hang</code></pre>
    <p>
      After <code>eret</code> brings a secondary core into EL1, execution begins here. The first step is to establish a usable stack. We calculate a temporary stack address using the core ID, ensuring that each core lands on its own region of memory without overlapping with others.
    
      Once the temporary stack is in place, we call <code>pickKernelStack</code> to get the actual per-core stack pointer, which is aligned and allocated from a static array. This value replaces the temporary one, and the core now has a proper stack to use.
    
      From there, we call <code>secondary_kernel_init</code>, which is the C-level entry point for non-primary cores. At this point, the core is ready to run in parallel with the rest of the system and can perform whatever tasks are assigned to it. We branch to proc_hang afterwards as a failsafe inces it ever returns from <code>secondary_kernel_init</code>, this it never is supposed to.
    </p>
    

    <h2>11. Exception Vector Table</h2>
    <pre><code>    .align 11
    _vectors:
        // Synchronous
        .align  7
        mov     x0, #0
        mrs     x1, esr_el1
        mrs     x2, elr_el1
        mrs     x3, spsr_el1
        mrs     x4, far_el1
        b       exc_handler
    
        // IRQ
        .align  7
        mov     x0, #1
        mrs     x1, esr_el1
        mrs     x2, elr_el1
        mrs     x3, spsr_el1
        mrs     x4, far_el1
        b       exc_handler
    
        // FIQ
        .align  7
        mov     x0, #2
        mrs     x1, esr_el1
        mrs     x2, elr_el1
        mrs     x3, spsr_el1
        mrs     x4, far_el1
        b       exc_handler
    
        // SError
        .align  7
        mov     x0, #3
        mrs     x1, esr_el1
        mrs     x2, elr_el1
        mrs     x3, spsr_el1
        mrs     x4, far_el1
        b       exc_handler</code></pre>
    <p>
      This is our exception vector table for EL1. It defines how the CPU should respond to various kinds of exceptions: synchronous faults, IRQs, FIQs, and system errors (SError). Each entry is 128 bytes apart, which is required for proper alignment when the processor jumps to a specific offset in the table based on the exception type.
    
      For each case, we load key registers into known locations: 
      <code>ESR_EL1</code> tells us what caused the exception, 
      <code>ELR_EL1</code> stores the address the CPU was executing when it happened, 
      <code>SPSR_EL1</code> is the saved program status, and 
      <code>FAR_EL1</code> gives the faulting address (for memory-related exceptions). 
      We also store an ID in <code>x0</code> to help the common handler distinguish the source.
    
      Finally, we branch to a shared <code>exc_handler</code>, where the exception is logged, handled, or causes a panic depending on the context. This keeps all exception types unified in a single place while still giving us the details needed to differentiate them.
    </p>
    
  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
