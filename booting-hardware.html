<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Booting on Real Hardware | Diego's Bare-Metal Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body class="bg-light text-dark">
  <div class="container py-5">
    <a href="index.html" class="btn btn-outline-secondary mb-4">‚Üê Back to Home</a>

    <h1>üß† Booting on Real Raspberry Pi 3B Hardware</h1>
    <p class="lead">What actually happens between powering on your Pi and your C code executing? Let‚Äôs walk through the full boot pipeline.</p>

    <hr>

    <h2>üîå Power-On to GPU Boot</h2>
    <p>
      The Raspberry Pi 3B begins execution from a small bit of on-chip ROM. This code runs on the <strong>GPU</strong>, not the CPU. The GPU looks for files on the SD card ‚Äî specifically a FAT32 partition with a file named <code>bootcode.bin</code>, and then <code>start.elf</code>. These are part of the closed-source GPU firmware provided by the Raspberry Pi Foundation.
    </p>
    <p>
      Once loaded, <code>start.elf</code> initializes the board‚Äôs hardware and then loads your <code>kernel8.img</code> into memory and jumps to it. If you're targeting AArch64 (64-bit mode), this file should contain your bare-metal kernel.
    </p>

    <h2>üìç Entry Point: <code>_start</code></h2>
    <p>
      The GPU jumps to the <code>_start</code> symbol inside your <code>kernel8.img</code>. This is the first instruction the CPU executes. At this point, the CPU is in EL2 (hypervisor mode) by default, and only core 0 is running.
    </p>
    <p>
      Your job here is to:
      <ul>
        <li>Lower the CPU to EL1 or EL0 (depending on your design)</li>
        <li>Set up the stack pointer</li>
        <li>Optionally initialize exception vectors and MMU</li>
        <li>Branch to your <code>main()</code> function in C</li>
      </ul>
    </p>

    <h2>üß† What About the Other Cores?</h2>
    <p>
      When the Pi boots, only <strong>core 0</strong> is executing. The other cores (1‚Äì3) are parked in a spin loop at an address in memory (usually around <code>0x00000000</code>). You can direct them to your own entry point by writing to <code>mailbox</code> addresses or defining startup trampolines.
    </p>
    <p>
      A simple strategy is to write an entry address for each core and send a "go" signal via memory-mapped mailboxes. In your assembly <code>_start</code>, you can then distinguish each core using the <code>mpidr_el1</code> register and direct them appropriately.
    </p>

    <h2>üõ†Ô∏è Setting up <code>config.txt</code></h2>
    <p>
      The Raspberry Pi relies on a configuration file named <code>config.txt</code> stored in the FAT32 boot partition. This file tells the GPU firmware how to initialize the hardware before jumping to your kernel.
    </p>
    <p>
      For bare-metal development, it‚Äôs crucial to modify <code>config.txt</code> to ensure that the firmware:
      <ul>
        <li>Boots in <strong>64-bit mode</strong> (required for <code>kernel8.img</code>)</li>
        <li>Disables features that interfere with your setup (like Bluetooth overlays)</li>
        <li>Stops passing Linux-specific boot arguments</li>
      </ul>
    </p>

    <h3>üîß Minimal Necessary Settings</h3>
    <p>
      Here's the important part of the <code>config.txt</code> that makes bare-metal booting work correctly:
    </p>

    <pre><code># Run in 64-bit mode
arm_64bit=1

# Disable HDMI overscan
disable_overscan=1

# Disable Bluetooth overlay
dtoverlay=disable-bt

# Prevent the firmware from modifying the command line
disable_commandline_tags=1

# Disable automatic UART initialization
uart_enable=0
</code></pre>

    <p>
      These settings ensure your CPU boots into the correct mode and that no unexpected Linux configuration interferes with your low-level initialization.
    </p>
    <p>
      You can leave the other commented-out options in <code>config.txt</code> alone for now; they're useful for HDMI tuning, overclocking, or enabling interfaces like I2C and SPI, which we'll cover in future posts.
    </p>

    <h2>üß™ Minimal Example</h2>
    <pre><code>_start:
  // Set up stack
  ldr x0, =_stack_top
  mov sp, x0

  // Get core ID
  mrs x1, mpidr_el1
  and x1, x1, #0x3      // core ID in bits [1:0]

  cmp x1, #0
  b.eq core0_main
  b    coreX_wait       // Park other cores

core0_main:
  bl main
  b .

coreX_wait:
  wfe
  b coreX_wait
</code></pre>

    <p>This assembly shows how to set up basic multi-core awareness at boot time.</p>

    <hr>
    <p><em>Next up: we‚Äôll talk about setting up the MMU and enabling data caching ‚Äî key steps to unlocking atomic instructions and improving performance.</em></p>

  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
