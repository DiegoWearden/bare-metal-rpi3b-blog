<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>UART and printf — GPIO Pin Configuration</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body class="bg-light text-dark">
  <div class="container py-5">

    <div class="alert alert-info">
      Reference: <a href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf" target="_blank">
        Broadcom BCM2835 ARM Peripherals Manual (PDF)
      </a>
    </div>

    <a href="index.html" class="btn btn-outline-secondary mb-4">⭠ Back to Home</a>
    <h1>UART and printf</h1>
    <p class="lead">
      In this section, we will focus on configuring the GPIO pins to enable UART0 output on the Raspberry Pi 3B.
    </p>
    <hr>

    <h2>Setting GPIO14 and GPIO15 to ALT0 for UART0</h2>
    <pre><code>selector = get32(GPFSEL1);
selector &= ~(7 << 12);                   // Clear bits 14:12 for GPIO14
selector |=  (4 << 12);                   // Set bits 14:12 to ALT0
selector &= ~(7 << 15);                   // Clear bits 17:15 for GPIO15
selector |=  (4 << 15);                   // Set bits 17:15 to ALT0
put32(GPFSEL1, selector);</code></pre>

    <h3>What is ALT0?</h3>
    <p>
      On the Raspberry Pi, most GPIO pins are multiplexed, which means each pin can perform multiple functions depending on how you configure it. In our case, we will be configuring it for UART.
    <p>
      Each GPIO pin supports several alternate functions named <code>ALT0</code>, <code>ALT1</code>, <code>ALT2</code>, and so on. These correspond to different internal hardware blocks. For example:
    </p>
    <ul>
      <li><code>ALT0</code> for GPIO14 = UART0 transmit (TXD0)</li>
      <li><code>ALT0</code> for GPIO15 = UART0 receive (RXD0)</li>
    </ul>

    <h3>What is GPFSEL1?</h3>
    <p>
       GPFSEL stands for GPIO Function Select which are registers that determine what function each GPIO pin performs. There are six of these registers: <code>GPFSEL0</code> through <code>GPFSEL5</code>. Each register controls 10 GPIO pins and each pin requires 3 bits to set its function.
    </p>
    <p>
      <code>GPFSEL1</code> covers GPIO pins 10 through 19. We care about:
    </p>
    <ul>
      <li><strong>GPIO14</strong>, which maps to bits <code>14:12</code> of <code>GPFSEL1</code></li>
      <li><strong>GPIO15</strong>, which maps to bits <code>17:15</code> of <code>GPFSEL1</code></li>
    </ul>
    <p>
      The function values are as follows:
    </p>
    <ul>
      <li><code>000</code> = Input</li>
      <li><code>001</code> = Output</li>
      <li><code>100</code> = ALT0 (which is UART0 for these pins)</li>
    </ul>

    <h3>Explanation of the Code</h3>
    <ul>
      <li>
        <code>get32(GPFSEL1)</code> reads the current value of the GPIO Function Select register for GPIOs 10–19. 
        Since GPIO14 and GPIO15 fall into this range, we start by fetching the current state so we can modify only the bits we care about without affecting other pins.
      </li>
      <li>
        <code>&amp;= ~(7 &lt;&lt; 12)</code> clears bits 14–12, which correspond to the function select field for GPIO14. 
        We must clear them first because we’re about to change this pin’s function, and we want to avoid leaving leftover bits that might point to a different mode.
      </li>
      <li>
        <code>|= 4 &lt;&lt; 12</code> sets bits 14–12 to <code>100</code>, which configures GPIO14 to use <code>ALT0</code>. 
        On the Pi 3B, this routes the pin to UART0’s TX (transmit) function.
      </li>
      <li>
        <code>&amp;= ~(7 &lt;&lt; 15)</code> and <code>|= 4 &lt;&lt; 15</code> perform the exact same logic for GPIO15, clearing its function bits and setting them to ALT0 mode. 
        This enables the UART0 RX (receive) line on that pin.
      </li>
      <li>
        <code>put32(GPFSEL1, selector)</code> writes the modified configuration back into the <code>GPFSEL1</code> register. 
        Only now do we commit the changes to the hardware, ensuring both pins are connected to the UART0 peripheral.
      </li>
    </ul>
    

    <p>
      After this configuration, GPIO14 and GPIO15 are connected to the UART0 hardware block inside the SoC. This allows us to send and receive serial data using the UART0 peripheral.
    </p>

    <h2>Disabling Pull-Up/Down Resistors</h2>
<pre><code>// Disable pull-up/down for all GPIO pins & delay for changes to take effect
put32(GPPUD, 0);
delay(150);
put32(GPPUDCLK0, (1 << 14) | (1 << 15));
delay(150);
put32(GPPUDCLK0, 0);</code></pre>

<p>
  GPIO pins on the Raspberry Pi have configurable internal pull-up and pull-down resistors. These resistors help stabilize the voltage level of a pin when it is not actively driven. Without them, a floating input pin could pick up random noise and behave unpredictably.
</p>

<p>
  When we use pins for UART (GPIO14 and GPIO15), we do not want any internal pull resistors affecting the voltage levels. UART lines are actively driven by both the Pi and the device it communicates with, so internal resistors would interfere with signal clarity.
</p>

<h3>Explanation of the Code</h3>
<ul>
  <li><code>GPPUD</code> is the GPIO Pull-Up/Down Register. Writing <code>0</code> disables both pull-up and pull-down resistors.</li>
  <li><code>delay(150)</code> waits to give the setting time to take effect (this is required by the Broadcom documentation).</li>
  <li><code>GPPUDCLK0</code> is the GPIO Pull-Up/Down Clock Register. Writing <code>1 &lt;&lt; 14 | 1 &lt;&lt; 15</code> tells the hardware to apply the pull-up/down setting (from <code>GPPUD</code>) to GPIO14 and GPIO15 specifically.</li>
  <li>Another <code>delay(150)</code> ensures the clock pulse is stable before we clear it.</li>
  <li><code>put32(GPPUDCLK0, 0)</code> clears the clock register to complete the update.</li>
</ul>

<p>
  This is how the Raspberry Pi’s hardware expects pull-up/down settings to be configured. If you skip it or apply it incorrectly, there is a chance UART output will be unstable.
</p>

  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
