<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Booting on Real Raspberry Pi 3B Hardware</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body class="bg-light text-dark">
  <div class="container py-5">
    <a href="index.html" class="btn btn-outline-secondary mb-4">← Back to Home</a>
    <h1>Getting to C on Real Hardware</h1>
    <p class="lead">
      Here’s how the Pi goes from power-on ROM to running your first C function in EL1. We’ll walk through each assembly step on the primary core, then show how the other cores join in.
    </p>
    <hr>

    <h2>1. GPU Firmware to Kernel Handoff</h2>
    <p>
      When the Raspberry Pi 3B powers on, the CPU doesn't start running right away. Instead, the GPU is the first to wake up. It runs a small bit of code from on-chip ROM that loads <code>bootcode.bin</code> from the SD card, which sets up the SDRAM so the system has usable memory. Then it loads <code>start.elf</code>, which configures things like the system clock and power management. Once everything is set up, the GPU loads your <code>kernel8.img</code> into memory and jumps to the <code>_start</code> label. At this point, core 0 begins executing your code in EL2.
    </p>    
    

    <h2>2. “Who Am I?”: Core ID Check</h2>
    <pre><code>_start:
        mrs   x0, mpidr_el1          // Read the Multiprocessor Affinity Register
        and   x0, x0, #0xFF          // Keep only the lowest 8 bits (core number)
        cbz   x0, master             // If that number is zero, we’re on core 0
        b     proc_hang              // Otherwise, park this core</code></pre>
    <p>
      When the CPU resets, every core has the same code in memory, but only one of them (core 0) actually needs to run the initialization sequence right away. We read <code>MPIDR_EL1</code>, which among other things tells us “I’m core 0,” “I’m core 1,” up to “I’m core 3.” The lowest eight bits of that register (called “Affinity Level 0”) hold exactly that piece of information. By masking with <code>0xFF</code>, we strip away everything else and end up with a number from 0 to 3. If it’s zero, this is the primary core and we jump into the <code>primary</code> setup. If it’s non-zero, we branch to <code>proc_hang</code> and wait quietly until the primary core wakes us later on.
    </p>
    
    

    <h2>3. Parking Secondary Cores</h2>
    <pre><code>proc_hang:
        wfe                     // Wait For Event: core goes into a low-power sleep
        b     proc_hang         // loop back and sleep again</code></pre>
    <p>
      Although on the real Pi 3B only core 0 ever enters our <code>_start</code> sequence at reset, we include this “parking” loop for cores 1–3 in case they do reach our code (for example in simulators or future platforms). Any core that branches here will sleep in place:  
      1. <code>wfe</code> halts the core until an event (a <code>sev</code>) arrives.  
      2. The branch back to <code>proc_hang</code> ensures it goes right back to sleep if no new work is ready.  
    
      In actual hardware, cores 1–3 start stalled inside the GPU’s ROM spin-loop and only get released when the primary core writes their start address into the mailboxes and issues <code>sev</code>. Once they land in our <code>secondary_kernel_main</code> code, this same parking loop is never used—instead, they follow the “wakeup” path we explicitly drive.  
    </p>
    

    <h2>4. Disabling Traps in EL2</h2>
    <pre><code>master:
        mov   x0, #0x33FF
        msr   cptr_el2, x0         // stop FP/SIMD faults to EL2
        msr   hstr_el2, xzr        // stop system-register traps
    
        mrs   x0, CPACR_EL1
        orr   x0, x0, #(1<<20)|(1<<21)
        msr   CPACR_EL1, x0        // allow FP/SIMD in EL1</code></pre>
    <p>
      These instructions disable traps that would otherwise occur when EL1 code tries to access floating-point or SIMD instructions. I'm still not completely sure why this setup is needed just to drop from EL2 to EL1, since no floating-point code runs at that point. However, I do know that if this part is left out, later code that uses floating-point instructions (either directly or through compiled C functions) will crash. So even if the immediate effect isn't obvious, it's important to have this in place early.
    </p>
    

    <h2>5. Setting Up the Hypervisor Register and VBAR</h2>
    <pre><code>    ldr   x0, =HCR_VALUE
        msr   hcr_el2, x0          // Set EL1 to use AArch64 execution state
    
        ldr   x0, =_vectors
        msr   vbar_el1, x0         // Set the exception vector base address for EL1</code></pre>
    <p>
      The <code>HCR_EL2</code> register controls how EL1 behaves when we return to it from EL2. Specifically, setting the <code>RW</code> bit (bit 31) to 1 tells the CPU that EL1 should run in AArch64 mode rather than AArch32. If this isn’t set, your code might end up running in the wrong execution state and behave unpredictably (or not at all).
    
      After that, we configure <code>VBAR_EL1</code>, which is the vector base address register for EL1. This tells the processor where to jump when an exception occurs (like an interrupt, system call, or fault) while running in EL1. By pointing it to our own <code>_vectors</code> table, we make sure any exceptions in our kernel get handled by our own code, not some undefined location.
    </p>
    

    <h2>6. Preparing to Return to EL1</h2>
    <pre><code>    mov   x0, #0x3C4
        msr   spsr_el2, x0         // Set up the saved program status for EL1
    
        adr   x0, el1_entry
        msr   elr_el2, x0          // Set the return address for when we drop to EL1
    
        eret                       // Exception return: jump to EL1</code></pre>
    <p>
      Before we can drop from EL2 to EL1, we need to tell the processor what kind of state EL1 should start in. <code>SPSR_EL2</code> controls that. The value <code>0x3C4</code> tells the CPU to enter EL1 in handler mode, which means it will use <code>sp_el1</code> as the active stack pointer. It also masks interrupts so they do not interfere with our setup.
    
      Next, we set <code>ELR_EL2</code>, which is the return address for when the CPU exits the current exception level. This is where the processor will jump once we execute <code>eret</code>. We point it to <code>el1_entry</code>, which is where our EL1 code begins.
    
      Finally, <code>eret</code> performs the transition. The CPU exits EL2 and starts executing at the address in <code>ELR_EL2</code> using the settings we placed in <code>SPSR_EL2</code>.
    </p>
    

    <h2>7. EL1 Entry: BSS Clear & Stack Setup</h2>
    <pre><code>el1_entry:
    adr   x0, __bss_start
    adr   x1, __bss_end
    sub   x1, x1, x0
    bl    memzero              // clear .bss

    mov   sp, #LOW_MEMORY      // temporary stack
    bl    pickKernelStack      // returns final SP in x0
    mov   sp, x0               // use it now

    bl    primary_kernel_init
    b     proc_hang</code></pre>
    <p>
      We zero uninitialized data, then explicitly build our C stack. First we point <code>sp</code> at a known safe address, call <code>pickKernelStack</code> to get a per-core stack, and then switch <code>sp</code> to it. Finally, we call into C.
    </p>

    <h2>8. Waking Up Secondary Cores</h2>
    <pre><code>wake_up_cores:
    adr   x0, secondary
    str   x0, [0xE0]           // entry for core 1
    str   x0, [0xE8]           // core 2
    str   x0, [0xF0]           // core 3
    sev                        // send event</code></pre>
    <p>
      Writing our EL1 entry address into each core’s mailbox and issuing <code>sev</code> wakes them from their <code>wfe</code> loops.
    </p>

    <h2>9. Secondary Core Initialization</h2>
    <pre><code>secondary_kernel_main:
    mrs   x0, mpidr_el1
    and   x0, x0, #0xFF
    mov   x1, #SECTION_SIZE
    mul   x1, x1, x0
    add   x1, x1, #LOW_MEMORY
    mov   sp, x1               // temporary stack

    bl    pickKernelStack
    mov   sp, x0               // final stack

    bl    secondary_kernel_init
    b     proc_hang</code></pre>
    <p>
      Each secondary core, after <code>eret</code>, runs this exact stack-setup in EL1 before calling its C init function.
    </p>

    <h2>10. Exception Vector Table</h2>
    <pre><code>.align 11
_vectors:
  // synchronous
  .align 7
  mov x0,#0; mrs x1,esr_el1; mrs x2,elr_el1; mrs x3,spsr_el1; mrs x4,far_el1
  b   exc_handler

  // IRQ
  .align 7
  mov x0,#1; mrs x1,esr_el1; mrs x2,elr_el1; mrs x3,spsr_el1; mrs x4,far_el1
  b   exc_handler

  // FIQ and SError follow the same pattern…</code></pre>
    <p>
      This table routes synchronous exceptions, IRQ, FIQ, and SError to your common <code>exc_handler</code>.
    </p>

    <hr>
    <p>
      We’ve kept every step explicit: disabling traps, configuring the hypervisor, performing the <code>eret</code> handoff, clearing memory, and setting the stack by hand. This approach puts you in full control of the Pi 3B’s boot sequence before any of your C code runs.
    </p>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
