<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Booting on Real Hardware | Diego's Bare-Metal Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body class="bg-light text-dark">
  <div class="container py-5">
    <a href="index.html" class="btn btn-outline-secondary mb-4">‚Üê Back to Home</a>

    <h1>Booting on Real Raspberry Pi 3B Hardware</h1>
    <p class="lead">How does your code actually start running on bare metal? Let‚Äôs break down how the Raspberry Pi 3B boots and how we can safely enter C code from EL2.</p>

    <hr>

    <h2>From Power-On to `kernel8.img`</h2>
    <p>
      When the Raspberry Pi 3B powers on, it starts in a small bit of read-only memory (ROM) inside the GPU. This ROM loads <code>bootcode.bin</code> and then <code>start.elf</code> from the SD card‚Äôs FAT32 partition.
    </p>
    <p>
      These closed-source binaries initialize the hardware and finally load your <code>kernel8.img</code> into memory. If you're targeting AArch64 (64-bit), <code>kernel8.img</code> should contain your bare-metal OS.
    </p>

    <h2>First Stop: <code>_start</code></h2>
    <p>
      Once the firmware hands control to your code, execution begins at the symbol <code>_start</code>. The CPU starts in EL2 (Hypervisor mode) by default, and only <strong>core 0</strong> is active.
    </p>
    <p>
      Our job is to:
      <ul>
        <li>Ensure only core 0 continues into the boot process</li>
        <li>Disable traps that would crash us in C</li>
        <li>Switch from EL2 to EL1 (the normal OS privilege level)</li>
        <li>Jump to our kernel C code</li>
      </ul>
    </p>

    <h2>üîß Minimal Boot Code</h2>
    <p>This is the minimal working code that sets up EL1 and calls your C entry point:</p>

    <pre><code>.section ".text.boot"
.global _start
_start:
    // Only core 0 continues
    mrs x0, mpidr_el1
    and x0, x0, #0xFF
    cbz x0, master
hang:
    wfe
    b hang

master:
    // Set stack for EL1
    ldr x0, =LOW_MEMORY
    msr sp_el1, x0

    // Disable traps and enable FP/SIMD for C compatibility
    mov x0, #0x33FF
    msr cptr_el2, x0
    msr hstr_el2, xzr
    mrs x0, cpacr_el1
    orr x0, x0, #(0b11 << 20)
    msr cpacr_el1, x0

    // Enable AArch64 for EL1
    mov x0, #(1 << 31)
    msr hcr_el2, x0

    // Set return state: EL1h mode, interrupts masked
    mov x0, #0x3C5
    msr spsr_el2, x0

    // Set return address to EL1 entry point
    adr x0, el1_entry
    msr elr_el2, x0

    // Drop to EL1
    eret

el1_entry:
    mov sp, #LOW_MEMORY
    bl primary_kernel_init
    b .
</code></pre>

    <p>This code ensures a clean transition into EL1, which is where your kernel‚Äôs C code will begin running.</p>

    <h2>Why We Disable Traps</h2>
    <p>
      The ARM architecture starts with traps enabled by default. If you don‚Äôt explicitly disable them, even basic C code may crash when it implicitly uses floating point registers or system instructions. We fix this by:
    </p>
    <ul>
      <li>Disabling FP/SIMD traps via <code>cptr_el2</code></li>
      <li>Allowing EL1 access to FP/SIMD via <code>cpacr_el1</code></li>
      <li>Clearing <code>hstr_el2</code> to avoid trapping sysregs</li>
    </ul>

    <h2>What About the Other Cores?</h2>
    <p>
      On boot, only core 0 runs your code. Cores 1‚Äì3 spin in a parking loop. Later, you can wake them using memory-mapped addresses or inter-core signaling with <code>sev</code>.
    </p>

    <h2>Next Steps</h2>
    <p>
      Now that we're in EL1 and running C code, the next steps are:
      <ul>
        <li>Setting up the MMU</li>
        <li>Enabling the data cache</li>
        <li>Initializing UART for early printf-style debugging</li>
      </ul>
    </p>

    <hr>
    <p><em>Up next: we‚Äôll walk through enabling the MMU and using the data cache ‚Äî a key step in getting atomic instructions and virtual memory working correctly.</em></p>

  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
