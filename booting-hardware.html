<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Booting on Real Raspberry Pi 3B Hardware</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body class="bg-light text-dark">
  <div class="container py-5">
    <a href="index.html" class="btn btn-outline-secondary mb-4">← Back to Home</a>
    <h1>Getting to C on Real Hardware</h1>
    <p class="lead">
      Here’s how the Pi goes from power-on ROM to running your first C function in EL1. We’ll walk through each assembly step on the primary core, then show how the other cores join in.
    </p>
    <hr>

    <h2>1. GPU Firmware to Kernel Handoff</h2>
    <p>
      When the Raspberry Pi 3B powers on, the CPU doesn't start running right away. Instead, the GPU is the first to wake up. It runs a small bit of code from on-chip ROM that loads <code>bootcode.bin</code> from the SD card, which sets up the SDRAM so the system has usable memory. Then it loads <code>start.elf</code>, which configures things like the system clock and power management. Once everything is set up, the GPU loads your <code>kernel8.img</code> into memory and jumps to the <code>_start</code> label. At this point, core 0 begins executing your code in EL2.
    </p>    
    

    <h2>2. “Who Am I?”: Core ID Check</h2>
    <pre><code>_start:
        mrs   x0, mpidr_el1          // Read the Multiprocessor Affinity Register
        and   x0, x0, #0xFF          // Keep only the lowest 8 bits (core number)
        cbz   x0, master             // If that number is zero, we’re on core 0
        b     proc_hang              // Otherwise, park this core</code></pre>
    <p>
      When the CPU resets, every core has the same code in memory, but only one of them (core 0) actually needs to run the initialization sequence right away. We read <code>MPIDR_EL1</code>, which among other things tells us “I’m core 0,” “I’m core 1,” up to “I’m core 3.” The lowest eight bits of that register (called “Affinity Level 0”) hold exactly that piece of information. By masking with <code>0xFF</code>, we strip away everything else and end up with a number from 0 to 3. If it’s zero, this is the primary core and we jump into the <code>primary</code> setup. If it’s non-zero, we branch to <code>proc_hang</code> and wait quietly until the primary core wakes us later on.
    </p>
    
    

    <h2>3. Parking Secondary Cores</h2>
    <pre><code>proc_hang:
        wfe                     // Wait For Event: core goes into a low-power sleep
        b     proc_hang         // loop back and sleep again</code></pre>
    <p>
      Although on the real Pi 3B only core 0 ever enters our <code>_start</code> sequence at reset, we include this “parking” loop for cores 1–3 in case they do reach our code (for example in simulators or future platforms). Any core that branches here will sleep in place:  
      1. <code>wfe</code> halts the core until an event (a <code>sev</code>) arrives.  
      2. The branch back to <code>proc_hang</code> ensures it goes right back to sleep if no new work is ready.  
    
      In actual hardware, cores 1–3 start stalled inside the GPU’s ROM spin-loop and only get released when the primary core writes their start address into the mailboxes and issues <code>sev</code>. Once they land in our <code>secondary_kernel_main</code> code, this same parking loop is never used—instead, they follow the “wakeup” path we explicitly drive.  
    </p>
    

    <h2>4. Disabling Traps in EL2</h2>
    <pre><code>master:
        mov   x0, #0x33FF
        msr   cptr_el2, x0         // stop FP/SIMD faults to EL2
        msr   hstr_el2, xzr        // stop system-register traps
    
        mrs   x0, CPACR_EL1
        orr   x0, x0, #(1<<20)|(1<<21)
        msr   CPACR_EL1, x0        // allow FP/SIMD in EL1</code></pre>
    <p>
      These instructions disable traps that would otherwise occur when EL1 code tries to access floating-point or SIMD instructions. I'm still not completely sure why this setup is needed just to drop from EL2 to EL1, since no floating-point code runs at that point. However, I do know that if this part is left out, later code that uses floating-point instructions (either directly or through compiled C functions) will crash. So even if the immediate effect isn't obvious, it's important to have this in place early.
    </p>
    

    <h2>5. Setting Up the Hypervisor Register and VBAR</h2>
    <pre><code>    ldr   x0, =HCR_VALUE
    msr   hcr_el2, x0          // EL1 runs 64-bit

    ldr   x0, =_vectors
    msr   vbar_el1, x0         // point EL1 exceptions here</code></pre>
    <p>
      <code>HCR_EL2.RW=1</code> switches EL1 into AArch64 mode. Then we install our exception vector table so that any trap in EL1 jumps to our handlers.
    </p>

    <h2>6. Preparing to Return to EL1</h2>
    <pre><code>    mov   x0, #0x3C4
    msr   spsr_el2, x0         // EL1h, interrupts masked

    adr   x0, el1_entry
    msr   elr_el2, x0          // where EL1 will start

    eret                       // perform exception return</code></pre>
    <p>
      We set up <code>SPSR_EL2</code> so that <code>eret</code> drops us into EL1h (EL1 with its own stack pointer) and masks interrupts. <code>ELR_EL2</code> tells the CPU to resume at <code>el1_entry</code>.
    </p>

    <h2>7. EL1 Entry: BSS Clear & Stack Setup</h2>
    <pre><code>el1_entry:
    adr   x0, __bss_start
    adr   x1, __bss_end
    sub   x1, x1, x0
    bl    memzero              // clear .bss

    mov   sp, #LOW_MEMORY      // temporary stack
    bl    pickKernelStack      // returns final SP in x0
    mov   sp, x0               // use it now

    bl    primary_kernel_init
    b     proc_hang</code></pre>
    <p>
      We zero uninitialized data, then explicitly build our C stack. First we point <code>sp</code> at a known safe address, call <code>pickKernelStack</code> to get a per-core stack, and then switch <code>sp</code> to it. Finally, we call into C.
    </p>

    <h2>8. Waking Up Secondary Cores</h2>
    <pre><code>wake_up_cores:
    adr   x0, secondary
    str   x0, [0xE0]           // entry for core 1
    str   x0, [0xE8]           // core 2
    str   x0, [0xF0]           // core 3
    sev                        // send event</code></pre>
    <p>
      Writing our EL1 entry address into each core’s mailbox and issuing <code>sev</code> wakes them from their <code>wfe</code> loops.
    </p>

    <h2>9. Secondary Core Initialization</h2>
    <pre><code>secondary_kernel_main:
    mrs   x0, mpidr_el1
    and   x0, x0, #0xFF
    mov   x1, #SECTION_SIZE
    mul   x1, x1, x0
    add   x1, x1, #LOW_MEMORY
    mov   sp, x1               // temporary stack

    bl    pickKernelStack
    mov   sp, x0               // final stack

    bl    secondary_kernel_init
    b     proc_hang</code></pre>
    <p>
      Each secondary core, after <code>eret</code>, runs this exact stack-setup in EL1 before calling its C init function.
    </p>

    <h2>10. Exception Vector Table</h2>
    <pre><code>.align 11
_vectors:
  // synchronous
  .align 7
  mov x0,#0; mrs x1,esr_el1; mrs x2,elr_el1; mrs x3,spsr_el1; mrs x4,far_el1
  b   exc_handler

  // IRQ
  .align 7
  mov x0,#1; mrs x1,esr_el1; mrs x2,elr_el1; mrs x3,spsr_el1; mrs x4,far_el1
  b   exc_handler

  // FIQ and SError follow the same pattern…</code></pre>
    <p>
      This table routes synchronous exceptions, IRQ, FIQ, and SError to your common <code>exc_handler</code>.
    </p>

    <hr>
    <p>
      We’ve kept every step explicit: disabling traps, configuring the hypervisor, performing the <code>eret</code> handoff, clearing memory, and setting the stack by hand. This approach puts you in full control of the Pi 3B’s boot sequence before any of your C code runs.
    </p>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
